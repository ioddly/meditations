* Application
** Arche
*** TODO Toasts
** Development
*** DONE Run all scripts concurrently
    CLOSED: [2020-11-23 Mon 14:34]
*** DONE Consider collapsing packages into a single mega-package
    CLOSED: [2020-11-24 Tue 16:37]
** Editor functionality
*** TODO hide formatting on bolding/italics
*** TODO allow escaping from headings
*** TODO List editing
*** TODO Allow creating collections on the fly
*** TODO Backlinks
*** TODO webpack-dev-server refreshing causes NoteRoute to fail with editor error
    This seems to be a bug in Slate itself -- I've tried stripping out all of my various extensions to a bare minimum component, but it is
    still not capable of hot refresh.

    https://github.com/ianstormtaylor/slate/issues/3621
    
    Disabling refresh via // @refresh reset fixes this.
    
    Or doesn't -- it also doesn't seem to behave well when being updated live in-place. Maybe I can do something to
    force remounting the component.


** Search
*** TODO Searchbar allows you to search for text, tags and collections
** Application functionality
*** TODO Create entries on a schedule
*** TODO Create entries from a template
*** TODO Navigation of some kind
*** TODO Error handling for recoverable and unrecoverable errors
** Frontend
*** TODO Route 404s
** API
*** TODO Type / function generation for frontend
*** TODO Load documents from and save to database
*** TODO Error handling
*** TODO graphql-constraint or some other easy validation for GraphQL
*** TODO Locking / multiple open session safety
*** TODO Subscribe to updates
** Freeform notes
** 2020-11-22 Picking up
   Starting to tackle this again. Left off with a partially constructed backend. Immediate goal is to get to a point
   where it's usable for day to day editing. The bare minimum for that would be a persistent backend and some more
   basic editing functionality. Functionality like collections / tags can come later. 
   
   I guess an interesting thing to do would be -- use this application to recreate this orgmode document. It should
   be well within its purview. 

   But in any case, for today, let's work on hooking up the backend.

   That being said, it might be worthwhile to continue to have an ephemeral editor instance untethered from the
   backend. For experimentation, but also just for quick note taking.

   Scratch.
   
   ---
   
   Ok. Have it generating some queries from my schema. Now I need to set up an urql client probably, then query my
   actual backend. The other thing is I have some type duplication now between backend/frontend/shared. Question is,
   are GraphQL types expressive and appropriate enough for my editor? No -- I'll probably have to translate at some
   points between the loosely typed GraphQL / database stuff and the well-typed document format. The main two components
   that will interact with well-typed documents will be the thing on the backend that parses documents into relations
   e.g. backlinks, collection entries, and the editor itself. Otherwise it probably will just be passing them around?
   
   So, get the graphql stuff to shared as well.
   
** 2020-11-23 DX + database hookup
   Today working on improving development a little bit and hooking things up so we're actually talking to the database.
   
   Working on loading documents. How do you handle reloading a big toplevel query? Probably only want to show loading
   states once. After that you load-in with animations. Do you pass around the re-execute thing you got? Maybe.
   
   ---
   
   Got to the point where you can create backend docs from the sidebar. Next step should probably be actually saving
   documents automatically. Then from there you can start to make the actual backend functionality (collection linking,
   search etc).
   
   Another backend problem, how do you / can you rename things? @Run can be stored as an entry pointing at collection
   @Run, but if we ever want to rename Run the only option is to parse all docs and rename. Another option is to store
   the collection id, but then rendering docs requires a join. Do you basically send back some kind of lookup table
   along with docs? e.g. {"collections": {"collection-12345": "Run"}}

   That actually doesn't sound profoundly painful. When sending back a document initially, you do these joins
   (collections, backlinks, tags) etc. Then from there updates only need to be made when changing a link of some kind.

   What can I get done this week?
   - Saving and updating documents
   - Creating collections on the fly and making entries in them
   - Basic search -- search for a collection, pin a note to a collection search
   - Basic navigation (beyond giant folder of all documents ever)
   - Improve document editing

** 2020-11-24 Database hookup continues

   Alright so I can create documents from the sidebar. Now I need to load & render them, then figure out an
   update/auto-save scheme. Also need a scratch editor exempted from saving and loading (or just into memory).
   
   Once I have basic saving hooked up, what's interesting? Search maybe.
  
   So when saving, let's save every X seconds when there is input. Flush when user leaves the page or route.

** 2020-11-25 Database hookup continues

   Working on a useAutosave hook that handles managing the interval and making the actual call to save things.
   
   --- 

   Finished up useAutosave. What's next? Editor improvements? Actual search? Searching for collections? Making collections work?

   Probably in a day I could make up some actual search-like functionality.

   So maybe:
   Make collections that are backed by an actual database object, and can be created on the fly.
   Think of a better name than collections, it reminds me of MongoDB.
   Search for collections.
   
   Buckets, bins, chunks, globs, tags, ats? Ats actually doesn't seem bad, in that it doesn't really have any baggage,
   tells you exactly how to initiate them (@), is less cumbersome to type. 
   
   What's the database look like?
   
   Does an "at" have a type? Or do its entries simply have types and an "at" has a default type? (Allowing you to change
   types without losing data)
   
   Are types more complex than just an enum?

   Does everything have a Y/N button on it? Or do just some of them? (For some of them, the mere act of filling it out
   would seem to be enough to register a "yes"). Is there a binary or yes/no version of each type of at?

   So an "at" has a type which is a composite of an enum as well as whether or not it requires yes/no? Does that seem good enough?
   
   Hmm. I'll start with this and see how it goes.

   What's an entry in an at called? An at node? I suppose that makes enough sense, considering that also lines up with
   where they actually come from.
   
   Finally, how do we store data? Is it denormalized? A JSONB column?

   Alright so how do I query the table? Clicking on "@Run" causes a SELECT * FROM at_notes WHERE at_id = 'x';
   
   What do you do here? One option would just be to return it and do all the analysis on the frontend for now.

   For example, click on an @Run queries @Run nodes from the last X days. You get all the at-nodes back and then you can
   render graphs out of the individual entries as well as stuff like SUM, MAX etc.
