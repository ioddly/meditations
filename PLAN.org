* Application
** Arche
*** TODO Toasts
** Development
*** DONE Run all scripts concurrently
    CLOSED: [2020-11-23 Mon 14:34]
*** DONE Consider collapsing packages into a single mega-package
    CLOSED: [2020-11-24 Tue 16:37]
** Editor functionality
*** TODO Undo
*** TODO Bug: Removing voids doesn't work quite as expected if they're not inline
*** TODO hide formatting on bolding/italics
*** TODO allow escaping from headings
*** TODO List editing
*** TODO Allow creating collections on the fly
*** TODO Backlinks
*** TODO webpack-dev-server refreshing causes NoteRoute to fail with editor error
    This seems to be a bug in Slate itself -- I've tried stripping out all of my various extensions to a bare minimum component, but it is
    still not capable of hot refresh.

    https://github.com/ianstormtaylor/slate/issues/3621
    
    Disabling refresh via // @refresh reset fixes this.
    
    Or doesn't -- it also doesn't seem to behave well when being updated live in-place. Maybe I can do something to
    force remounting the component.


** Search
*** TODO Searchbar allows you to search for text, tags and collections
** Application functionality
*** TODO Create entries on a schedule
*** TODO Create entries from a template
*** TODO Navigation of some kind
*** TODO Error handling for recoverable and unrecoverable errors
*** TODO Archival / soft deletion
** Frontend
*** TODO Route 404s
*** TODO Shared error handling
** Bugs
*** TODO Tags and other voids break markdown
** API
*** TODO Type / function generation for frontend
*** TODO Load documents from and save to database
*** TODO Error handling
*** TODO graphql-constraint or some other easy validation for GraphQL
*** TODO Locking / multiple open session safety
*** TODO Subscribe to updates
** Freeform notes
** 2020-11-22 Picking up
   Starting to tackle this again. Left off with a partially constructed backend. Immediate goal is to get to a point
   where it's usable for day to day editing. The bare minimum for that would be a persistent backend and some more
   basic editing functionality. Functionality like collections / tags can come later. 
   
   I guess an interesting thing to do would be -- use this application to recreate this orgmode document. It should
   be well within its purview. 

   But in any case, for today, let's work on hooking up the backend.

   That being said, it might be worthwhile to continue to have an ephemeral editor instance untethered from the
   backend. For experimentation, but also just for quick note taking.

   Scratch.
   
   ---
   
   Ok. Have it generating some queries from my schema. Now I need to set up an urql client probably, then query my
   actual backend. The other thing is I have some type duplication now between backend/frontend/shared. Question is,
   are GraphQL types expressive and appropriate enough for my editor? No -- I'll probably have to translate at some
   points between the loosely typed GraphQL / database stuff and the well-typed document format. The main two components
   that will interact with well-typed documents will be the thing on the backend that parses documents into relations
   e.g. backlinks, collection entries, and the editor itself. Otherwise it probably will just be passing them around?
   
   So, get the graphql stuff to shared as well.
   
** 2020-11-23 DX + database hookup
   Today working on improving development a little bit and hooking things up so we're actually talking to the database.
   
   Working on loading documents. How do you handle reloading a big toplevel query? Probably only want to show loading
   states once. After that you load-in with animations. Do you pass around the re-execute thing you got? Maybe.
   
   ---
   
   Got to the point where you can create backend docs from the sidebar. Next step should probably be actually saving
   documents automatically. Then from there you can start to make the actual backend functionality (collection linking,
   search etc).
   
   Another backend problem, how do you / can you rename things? @Run can be stored as an entry pointing at collection
   @Run, but if we ever want to rename Run the only option is to parse all docs and rename. Another option is to store
   the collection id, but then rendering docs requires a join. Do you basically send back some kind of lookup table
   along with docs? e.g. {"collections": {"collection-12345": "Run"}}

   That actually doesn't sound profoundly painful. When sending back a document initially, you do these joins
   (collections, backlinks, tags) etc. Then from there updates only need to be made when changing a link of some kind.

   What can I get done this week?
   - Saving and updating documents
   - Creating collections on the fly and making entries in them
   - Basic search -- search for a collection, pin a note to a collection search
   - Basic navigation (beyond giant folder of all documents ever)
   - Improve document editing

** 2020-11-24 Database hookup continues

   Alright so I can create documents from the sidebar. Now I need to load & render them, then figure out an
   update/auto-save scheme. Also need a scratch editor exempted from saving and loading (or just into memory).
   
   Once I have basic saving hooked up, what's interesting? Search maybe.
  
   So when saving, let's save every X seconds when there is input. Flush when user leaves the page or route.

** 2020-11-25 Database hookup continues

   Working on a useAutosave hook that handles managing the interval and making the actual call to save things.
   
   --- 

   Finished up useAutosave. What's next? Editor improvements? Actual search? Searching for collections? Making collections work?

   Probably in a day I could make up some actual search-like functionality.

   So maybe:
   Make collections that are backed by an actual database object, and can be created on the fly.
   Think of a better name than collections, it reminds me of MongoDB.
   Search for collections.
   
   Buckets, bins, chunks, globs, tags, ats? Ats actually doesn't seem bad, in that it doesn't really have any baggage,
   tells you exactly how to initiate them (@), is less cumbersome to type. 
   
   What's the database look like?
   
   Does an "at" have a type? Or do its entries simply have types and an "at" has a default type? (Allowing you to change
   types without losing data)
   
   Are types more complex than just an enum?

   Does everything have a Y/N button on it? Or do just some of them? (For some of them, the mere act of filling it out
   would seem to be enough to register a "yes"). Is there a binary or yes/no version of each type of at?

   So an "at" has a type which is a composite of an enum as well as whether or not it requires yes/no? Does that seem good enough?
   
   Hmm. I'll start with this and see how it goes.

   What's an entry in an at called? An at node? I suppose that makes enough sense, considering that also lines up with
   where they actually come from.
   
   Finally, how do we store data? Is it denormalized? A JSONB column?

   Alright so how do I query the table? Clicking on "@Run" causes a SELECT * FROM at_notes WHERE at_id = 'x';
   
   What do you do here? One option would just be to return it and do all the analysis on the frontend for now.

   For example, click on an @Run queries @Run nodes from the last X days. You get all the at-nodes back and then you can
   render graphs out of the individual entries as well as stuff like SUM, MAX etc.

   That seems good enough to start with anyway and easier to reason about than translating it to SQL. Can always make
   it good later.
   
   Good stopping point. Tomorrow: Figure out @s and #s
   
   One thought is to load them all upfront into Redux. That makes querying relatively easy at the cost of: multiple
   clients could get out of sync, there could be a lot of them eventually (although based on my current 7 year history
   in meditations, there's probably only going to be a couple hundred).
   
   Update: Actually, I'll start with tags since they will be simpler and should establish the same code paths.

   - Load tags on startup
   - When saving a document, auto create any tags and tag relations that need to exist. (We could also create on
     insertion into document? But auto creation on document save seems possible and simplifies frontend. You keep a
     mapping of (tag_id, tag_name) in Redux, and the completion component has the ability to add something to this
     immediately on creation, ensuring that tag_id will be used later in that document or elsewhere.

** 2020-11-26 Working on adding tag support

   Decided to go with tags because they're simpler to start with. Added a getTags endpoint that retrieves all tags -- do
   this on startup and keep it in Redux. Once it's there, users should be able to add a new tag by typing.
   
   Turns out Slate doesn't like me inserting freeform text. (Makes sense) Question though is how do I do it?
   
   Oh I just have to make them a void. That's kind of annoying if you want to inline edit tags, but it's also probably
   easier to reason about and not too hard to just...re-type tags.

** 2020-12-23 Working on tags

   If I recall where I left off correctly, I need to: preload a mapping of tags to actual tag IDs, then add the ability
   to 1) map that to actual names and 2) add tags on the fly.

** 2020-12-30 Working on tags
   
   I'm gonna really do it this time! I'm going to add tags that you can search for.
   
   So first thing we do is load a mapping of tags into Redux, on app start

   When you add a tag, it'll grab a tag from the store or create a tag in the backend.
   
   Alright so I'm now loading all tags at startup into the Redux store. When a user references a tag, we check the tag
   map, add a new tag if not found, and save. When we save the document, it will parse the tags into a series of
   relations.
   
   -->

   Getting there! I can create tags on the fly and am now going to parse and create relations off of them. I also did
   some side quests to improve error reporting and make it look a little nicer. I think I'd like to finish up by
   creating actual database relations based off the latest revision, in a transaction.
   
   -->

   Surprisingly first attempt at creating relations Just Worked, so now I'm going to try to get search going in some format.
   
   Alright so I have search pulling up some records based on tags. Next step is to figure out how to actually display
   some search results. Like if you search for #asdf, does it give you the entirety of everything containing #asdf? does
   it show you the sections containing #asdf? 

   What's most valuable to do next? I think ats are the thing I actually care about, the thing that differentiates this
   from anything else.

   How does tagging ats work by the way? I want to be able to put them in a section like

   ## #project/techne
   @Work (30min)
   
   Then be able to search for work against a particular project.

   (This is something I can do while parsing as well)
   
   Alright for tomorrow, let's get ats working.
   
   
